/**
 * Product Manager Agent
 * Analyzes requirements and creates PRD documents
 */

import type { Env, Task, AgentId, KnowledgeEntry } from '../types';
import { Logger } from '../utils/logger';
import { KnowledgeBase } from '../core/knowledge-base';

export class ProductManagerAgent {
  private logger: Logger;
  private knowledgeBase: KnowledgeBase;
  private agentId: AgentId = 'agent-pm';

  constructor(private env: Env) {
    this.logger = new Logger(env, 'ProductManagerAgent');
    this.knowledgeBase = new KnowledgeBase(env);
  }

  /**
   * Process a task to write a PRD
   */
  async processTask(task: Task): Promise<{
    prd: KnowledgeEntry;
    user_stories: string[];
    acceptance_criteria: string[];
  }> {
    await this.logger.info('Processing PRD task', { taskId: task.id }, this.agentId);

    const requirements = task.description || '';

    // Analyze requirements
    const analysis = await this.analyzeRequirements(requirements);

    // Research similar features in knowledge base
    const similarFeatures = await this.researchSimilarFeatures(requirements);

    // Generate PRD
    const prd = await this.generatePRD({
      requirements,
      analysis,
      similarFeatures,
      taskId: task.id,
    });

    // Extract user stories and acceptance criteria
    const userStories = this.extractUserStories(prd.content);
    const acceptanceCriteria = this.extractAcceptanceCriteria(prd.content);

    // Save PRD to knowledge base
    await this.knowledgeBase.createEntry({
      type: 'prd',
      title: prd.title,
      content: prd.content,
      tags: prd.tags,
      related_tasks: [task.id],
      author_agent_id: this.agentId,
    });

    await this.logger.info('PRD created successfully', { prdId: prd.id }, this.agentId);

    return {
      prd,
      user_stories: userStories,
      acceptance_criteria: acceptanceCriteria,
    };
  }

  /**
   * Analyze user requirements
   */
  private async analyzeRequirements(requirements: string): Promise<{
    problem_statement: string;
    target_users: string[];
    core_value: string;
    business_goals: string[];
  }> {
    // In production, this would use AI to analyze requirements
    // For now, return a structured analysis
    return {
      problem_statement: `User needs: ${requirements}`,
      target_users: ['End users', 'System administrators'],
      core_value: 'Improve user experience and system functionality',
      business_goals: ['Increase user engagement', 'Reduce operational costs'],
    };
  }

  /**
   * Research similar features from knowledge base
   */
  private async researchSimilarFeatures(requirements: string): Promise<KnowledgeEntry[]> {
    const results = await this.knowledgeBase.search(requirements, {
      type: 'prd',
      limit: 3,
    });

    return results;
  }

  /**
   * Generate PRD document
   */
  private async generatePRD(input: {
    requirements: string;
    analysis: {
      problem_statement: string;
      target_users: string[];
      core_value: string;
      business_goals: string[];
    };
    similarFeatures: KnowledgeEntry[];
    taskId: string;
  }): Promise<KnowledgeEntry> {
    const prdContent = `# Product Requirements Document

## Background and Goals
${input.analysis.problem_statement}

### Target Users
${input.analysis.target_users.map((u) => `- ${u}`).join('\n')}

### Core Value Proposition
${input.analysis.core_value}

### Business Goals
${input.analysis.business_goals.map((g) => `- ${g}`).join('\n')}

## User Stories
- As a user, I want to ${input.requirements}, so that I can achieve my goals
- As an admin, I want to manage this feature effectively
- As a developer, I want clear implementation guidelines

## Functional Requirements

### Core Features
1. **Feature Implementation**: ${input.requirements}
2. **User Interface**: Intuitive and responsive UI
3. **Data Management**: Proper data validation and storage
4. **Error Handling**: Comprehensive error handling and user feedback

### Non-Functional Requirements
1. **Performance**: Response time < 500ms
2. **Security**: Proper authentication and authorization
3. **Scalability**: Handle increasing load
4. **Maintainability**: Clean, documented code

## Acceptance Criteria
- [ ] Feature implements all functional requirements
- [ ] All tests pass with >80% coverage
- [ ] Performance metrics meet targets
- [ ] Security audit passes
- [ ] Documentation is complete

## Risks and Dependencies
- **Technical Risks**: Potential complexity in implementation
- **Dependencies**: Related tasks must be completed first
- **Mitigation**: Regular checkpoints and code reviews

## Success Metrics
- Feature adoption rate > 70%
- User satisfaction score > 4/5
- Bug rate < 2%

---
*Generated by PM Agent for Task ${input.taskId}*
`;

    const prd: KnowledgeEntry = {
      id: `prd-${Date.now()}`,
      type: 'prd',
      title: `PRD: ${input.requirements}`,
      content: prdContent,
      tags: ['prd', 'requirements', 'planning'],
      related_tasks: [input.taskId],
      author_agent_id: this.agentId,
      created_at: Date.now(),
      updated_at: Date.now(),
    };

    return prd;
  }

  /**
   * Extract user stories from PRD
   */
  private extractUserStories(prdContent: string): string[] {
    const stories: string[] = [];
    const lines = prdContent.split('\n');
    let inUserStories = false;

    for (const line of lines) {
      if (line.includes('## User Stories')) {
        inUserStories = true;
        continue;
      }
      if (inUserStories && line.startsWith('##')) {
        break;
      }
      if (inUserStories && line.trim().startsWith('- As')) {
        stories.push(line.trim().substring(2));
      }
    }

    return stories;
  }

  /**
   * Extract acceptance criteria from PRD
   */
  private extractAcceptanceCriteria(prdContent: string): string[] {
    const criteria: string[] = [];
    const lines = prdContent.split('\n');
    let inCriteria = false;

    for (const line of lines) {
      if (line.includes('## Acceptance Criteria')) {
        inCriteria = true;
        continue;
      }
      if (inCriteria && line.startsWith('##')) {
        break;
      }
      if (inCriteria && line.trim().startsWith('- [')) {
        criteria.push(line.trim().substring(5).replace(']', '').trim());
      }
    }

    return criteria;
  }

  /**
   * Validate PRD completeness
   */
  async validatePRD(prdId: string): Promise<{
    valid: boolean;
    missing_sections: string[];
    warnings: string[];
  }> {
    const prd = await this.knowledgeBase.getEntry(prdId);
    if (!prd) {
      return {
        valid: false,
        missing_sections: ['PRD not found'],
        warnings: [],
      };
    }

    const requiredSections = [
      'Background and Goals',
      'User Stories',
      'Functional Requirements',
      'Acceptance Criteria',
      'Risks and Dependencies',
    ];

    const missingSections: string[] = [];
    for (const section of requiredSections) {
      if (!prd.content.includes(section)) {
        missingSections.push(section);
      }
    }

    const warnings: string[] = [];
    if (!prd.tags || prd.tags.length === 0) {
      warnings.push('No tags specified');
    }
    if (!prd.related_tasks || prd.related_tasks.length === 0) {
      warnings.push('No related tasks linked');
    }

    return {
      valid: missingSections.length === 0,
      missing_sections: missingSections,
      warnings,
    };
  }
}
